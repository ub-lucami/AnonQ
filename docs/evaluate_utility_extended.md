# Functional Description and Utility Evaluation for Elderly Monitoring System

This document describes the event types and time periods used in an elderly monitoring system, outlines the predictive modeling goals for operator support, and explains how to evaluate the utility of a hierarchical anonymization procedure. The evaluation is implemented in the Python script `evaluate_utility_extended.py`, which compares predictive performance across three dataset variants to quantify the privacy–utility trade-off.

## 1. Event Categories (Functional Definitions)

Events are generated by emergency buttons and fall-detection devices and reflect the resident’s cognitive or physical safety state at the time of triggering.

1. **`emergency_button`**  
   - Raw codes: `EMERGENCY_BUTTON_PRESSED`, `CONTROL_PANEL.EMERGENCY_BUTTON_PRESSED`, `EMERGENCY_PENDANT.EMERGENCY_BUTTON_PRESSED`, `PULL_CORD.EMERGENCY_BUTTON_PRESSED`  
   - Meaning: Manual activation indicating perceived danger, request for help, confusion, panic, discomfort, or (rarely) accidental press.  
   - Priority: High – requires prompt operator attention.

2. **`fall_detected`**  
   - Raw code: `FALL_DETECTOR.FALL_DETECTED`  
   - Meaning: Fall-detection sensor identified a probable fall (rapid acceleration + inactivity, abnormal posture, or impact pattern).  
   - Priority: Critical – immediate response required.

3. **`fall_cancelled`**  
   - Raw code: `FALL_DETECTOR.FALL_DETECTION_CANCELED`  
   - Meaning: Previously triggered fall alert was cancelled (resident resumed normal movement, sensor reassessment, or user pressed “I’m OK”).  
   - Interpretation: False alarm or resolved situation.

4. **`fall_idle`**  
   - Raw code: `FALL_DETECTOR.NOT_MOVING`  
   - Meaning: Extended period of inactivity detected.  
   - Possible causes: post-fall immobility, normal sleep, device not worn, or early distress.  
   - Interpretation: Context-dependent (time of day, history, care plan).

## 2. Time-Period Definitions

Events are assigned to one of four daily periods to reflect circadian rhythms, typical activity levels, and risk windows.

- **`night`**  
  Time: 22:00 – 06:00  
  Context: Sleep or very low activity. Events here are clinically more concerning (nighttime wandering, confusion, bathroom falls).

- **`morning`**  
  Time: 06:00 – 08:00  
  Context: Wake-up and morning routine. Elevated risk of falls during transfers (bed → standing, bathroom use).

- **`daytime`**  
  Time: 08:00 – 17:00  
  Context: Peak activity window (meals, therapy, walking, visits). Most routine and benign events occur here.

- **`afternoon`**  
  Time: 17:00 – 22:00  
  Context: Transition to evening. Increased risk of sundowning / confusion in residents with cognitive impairment.

## 3. Predictive Modeling Goals for Operators

The model should support triage, risk prioritization, and early detection of decline rather than merely predicting raw events.

### Most Valuable Outputs
- Probability of next critical event (`emergency_button`, `fall_detected`) in the coming hours
- Top-3 most likely next events with confidence scores
- Fall-risk score for specific time windows (e.g., tonight, next morning)
- Behavioral stability indicators (today vs. historical weekday / time-period pattern)
- Detection of risk shifts (↑ `fall_idle` this week, ↑ nighttime buttons this month)
- Unusual event sequences (e.g., `fall_idle → fall_detected → emergency_button`)
- Visual summaries: 24-hour risk curve, 7-day event profile, per-resident heatmap

### Core Predictive Features
| Feature                  | Captures                     | Operator Relevance |
|--------------------------|------------------------------|--------------------|
| `time_period`            | Circadian / daily rhythm     | ★★★★★             |
| `weekday`                | Weekly routine               | ★★★★☆             |
| `hierarchical week_number` | Seasonal / annual patterns | ★★★☆☆             |
| `GUID`                   | Individual behavior baseline | ★★★★★             |
| Past N events / sequences| Short-term context           | ★★★★★             |

## 4. Hierarchical Anonymization Procedure

**Rule**  
- If the combination (`GUID` + event pattern) has ≥ **k** residents → keep exact `week_number`  
- Otherwise → remove `week_number` for those rows  
- Rows that cannot meet k-anonymity after removal may also be dropped

**Goal**  
Preserve as much seasonal signal as possible while guaranteeing k-anonymity.

## 5. Utility Evaluation – Three Dataset Variants

All variants are derived from the same master anonymized file (`anonymized_events.csv` – 26,764 events).

| Dataset        | Size     | `week_number` handling                                 | Purpose                              |
|----------------|----------|--------------------------------------------------------|--------------------------------------|
| **season**     | ~20,721  | Only rows where `week_number` is present and valid     | Best available seasonal information  |
| **no_season**  | 26,764   | Column completely removed                              | Baseline without any seasonality     |
| **hierarchical** | 26,764 | Missing values → `"unknown"` + binary `wk_missing_flag`| Actual production anonymization      |

## 6. Evaluation Script: `evaluate_utility_extended.py`

### Purpose
Quantify whether the hierarchical anonymization preserves enough predictive utility compared to:
- having full seasonal detail (where available), and
- having no seasonal detail at all.

### Methodology
- Train identical **LightGBM** classifiers to predict `generalized_event` on each dataset variant
- Use same random train/test split (stratified by event type)
- Encode categoricals consistently
- For **hierarchical** dataset: fill missing `week_number` with `"unknown"` and add `wk_missing_flag`

### Key Metrics
- Accuracy, Macro-F1, Top-3 Accuracy
- Per-class F1 for `fall_detected` and `emergency_button`
- Per-time-period F1 (especially **night** and **morning**)
- Bootstrap confidence intervals
- Paired statistical tests (t-test / Wilcoxon)

### Utility Scores
```text
Gain_season    = F1(hierarchical) - F1(no_season)
                 → value added by partial seasonal information

Loss_size      = F1(hierarchical) - F1(season)
                 → cost of having mixed / partial season detail

Utility_ratio  = F1(hierarchical) / F1(no_season)
                 → > 1.0 means hierarchical is clearly preferable